" vim:set ft=vim:

augroup mycomplete
	autocmd!
	autocmd BufEnter * :set completefunc=CamelRegComplete
"	autocmd BufEnter * :set completefunc=RegexComplete
augroup END

function! CamelRegComplete(findstart, base)
    if a:findstart
		return FindWordHeadPos()
    endif

    let words = FindWords()
	let pattern = CreatePattern(a:base)

	call CompleteAdd(words, pattern)
endfunction

function! FindWords()
python << EOM

pattern = re.compile(r'\w\w*\w')

words = lambda line: pattern.findall(line)

import vim
result = []
for buf in vim.buffers:
	for line in buf:
		result = result + words(line)

vim.command('return %s' % sorted(result, key=lambda c: c.lower()))

EOM
endfunction

function! CreatePattern(base)
	if a:base == ''
		return '.*'
	else
		return CreateReg(a:base)
	endif
endfunction

function! CreateReg(base)
python << EOM

result = ''
firstUpper = True
base = vim.eval('a:base')
for i in range(len(base)):
	c = base[i]
	if c.isupper():
		if firstUpper:
			firstUpper = False
			if i == 0:
				tmpformat = '%s%s.*'
			else:
				tmpformat = '%s.*%s.*'
		else:
			tmpformat = '%s%s.*'
	elif c == '*':
		tmpformat = '%s.%s'
	else:
		tmpformat = '%s%s'

	result = tmpformat % (result, c)


lastformat = '^%s' if '*' in result else '^%s'

vim.command('return "%s"' % (lastformat % result))

EOM
endfunction

function! CompleteAdd(words, pattern)
    for word in a:words
		if word =~# a:pattern
			call complete_add({'word' : word})
		endif
    endfor
endfunction

source $mycomplete/CamelRegCompleteTest





"todo s:


function! RegexComplete(findstart, base)
    if a:findstart
		return FindWordHeadPos()
    endif

    let words = FindWords2()
	let pattern = CreatePattern2(a:base)

	call AddComplete(words, pattern)
endfunction

function! FindWordHeadPos()
	let currentLine = strpart(getline('.'), 0, col('.') - 1)
	return match(currentLine, '[a-zA-Z*$_]*$')
endfunction

function! FindWords2()
	return ['hoge', 'fuga', 'piyo']
endfunction

function! CreatePattern2(base)
	let result = ''

	for i in range(len(a:base))
		if IsFirstCharacter(i)
			let result .= FirstCharacter(i, a:base)

		elseif IsLastCharacter(i, a:base)
			let result .= LastCharacter(i, a:base)

		else
			let result .= MiddleCharacter(i, a:base)
		endif
	endfor

	return result
endfunction

function! IsFirstCharacter(i)
	return a:i == 0
endfunction

function! IsLastCharacter(i, string)
	return a:i == len(a:string) - 1
endfunction

" *abc -> .*
" abc -> ^a.*
function! FirstCharacter(i, string)
	if a:string[a:i] == '*'
		return '.*'
	else
		return '^' . a:string[a:i] . '.*'
	endif
endfunction

" abc$ -> $
" abc -> c.*
function! LastCharacter(i, string)
	if a:string[a:i] == '$'
		return '$'
	else
		return a:string[a:i] . '.*'
	endif
endfunction

" abc -> b.*
function! MiddleCharacter(i, string)
	return a:string[a:i] . '.*'
endfunction

function! AddComplete(words, pattern)
	let result = []
    for word in a:words
		if word =~? a:pattern
			call complete_add({'word' : word})
			let result = add(result, word)
		endif
    endfor
	return result
endfunction
