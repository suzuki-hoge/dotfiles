" vim:set ft=vim:

python << EOM

class Case:

	def __init__(self, base, expected):
		self.base = base
		self.expected = expected

class Cases:

	def __init__(self, func):
		self.func = func
		self.cases = []

	def add(self, base, expected):
		case = Case(base, expected)
		self.cases.append(case)

	def test(self):
		for case in self.cases:
			actual = self.__test(case)
			self.__output(actual, case)

	def __output(self, actual, case):
		print '[%s] %s(%s) -> %s' % ('OK' if case.expected == actual else 'NG', self.func, case.base, actual)
		if case.expected != actual:
			print '  expected : %s\n  actual   : %s' % (case.expected, actual)

	def __test(self, case):
		return vim.eval("%s('%s')" % (self.func, case.base))

EOM



" aaaCRT
" Trans
" Transfer
function! CreateRegTest()
python << EOM

cases = Cases('CreateReg')

cases.add('service',   '^service')
cases.add('serviceE',  '^service.*E.*')
cases.add('sEL',       '^s.*E.*L.*')
cases.add('sEy',       '^s.*E.*y')
cases.add('serviEL',   '^servi.*E.*L.*')
cases.add('serviEs',   '^servi.*E.*s')
cases.add('s*vice',    '^s.*vice')
cases.add('s*vice*',   '^s.*vice.*')
cases.add('s*viceEs',  '^s.*vice.*E.*s')
cases.add('s*viceEL',  '^s.*vice.*E.*L.*')
cases.add('s*viceELt', '^s.*vice.*E.*L.*t')
cases.add('CRT',       '^C.*R.*T.*')
cases.add('Tr',        '^T.*r')

cases.test()

EOM
endfunction

"command! T w | source $rc | call CreateRegTest()
"command! T w | source $rc | call CreateRegTest2()

function! CreateRegTest2()
	call s:test([], '',       '',             [])
	call s:test([], '*',      '.*',           [])
	call s:test([], 'a',      '^a.*',         [])
	call s:test([], 'abc',    '^a.*b.*c.*',   [])
	call s:test([], '*abc',   '.*a.*b.*c.*',  [])
	call s:test([], 'abc$',   '^a.*b.*c.*$',  [])
	call s:test([], '*abc$',  '.*a.*b.*c.*$', [])
	call s:test([], 'aBc',    '^a.*B.*c.*',   [])
	call s:test([], 'aBC',    '^a.*B.*C.*',   [])
endfunction

function! s:test(words, key, pattern, result)
	call s:patternTest(a:key, a:pattern)
"	call s:completeTest(a:words, a:pattern, a:result)
	echo ' '
endfunction

function! s:patternTest(key, pattern)
	let expected = a:pattern
	let actual = CreatePattern2(a:key)

	call s:assert(expected, actual)
endfunction

function! s:completeTest(words, pattern, result)
	let expected = a:result
	let actual = AddComplete(a:words, a:pattern)

	call s:assert(expected, actual)
endfunction

function! s:assert(expected, actual)
	if a:expected == a:actual
		echo 'OK | '
	else
		echo 'NG | '
	endif
	echon a:expected
	echon ' -> '
	echon a:actual
endfunction
